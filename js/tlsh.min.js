(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Tlsh = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var ProcessedBuckets = require('./processed-buckets');
var SlideWindow = require('./slide-window');
var Quartiles = require('./quartiles');

var ProcessBuckets = (function() {
    
    var ARRAY_BUCKET_SIZE = 256;

    var buildProcessedBuckets = function(dataLength, bucketArray, checksum){
        var quartiles = new Quartiles(bucketArray);
        return new ProcessedBuckets(checksum, bucketArray, dataLength, quartiles);
    };

    var process = function(data){
        var length = data ? data.length : 0;

        var bucketArray = Array.apply(null, Array(ARRAY_BUCKET_SIZE)).map(Number.prototype.valueOf,0);
        var checksum;
        var slideWindow = new SlideWindow();

        var that = this;

        var populateBucket = function(hash){
            if(!bucketArray[hash]){
                bucketArray[hash] = 1;
            } else {
                bucketArray[hash]++;
            }
        };

        for(var i = 0; i < length; i++) {
            var code = data.charCodeAt(i);

            var startWindow = slideWindow.getPivot();
            slideWindow.put(code);

            checksum = slideWindow.getChecksum(startWindow, checksum);
            slideWindow.getTripletHashes(startWindow).forEach(populateBucket);
        }

        return buildProcessedBuckets(length, bucketArray, checksum);
    };

    return process;
})();

module.exports = ProcessBuckets;
},{"./processed-buckets":4,"./quartiles":5,"./slide-window":6}],2:[function(require,module,exports){
var Body = require('../digests/body');
var Checksum = require('../digests/checksum');
var Digest = require('../digests/digest');
var LValue = require('../digests/lvalue');
var Q = require('../digests/q');

var DigestBuilder = function() {
    
    var MOD_VALUE = 256;

    var LOG_1_1 = 0.095310180;

    var LOG_1_3 = 0.26236426;

    var LOG_1_5 = 0.4054651;

    var checksum;

    var lValue;

    var q;

    var body;

    var Ranges = {
        LOW: 656,
        MID: 3199
    };

    var withChecksum = function(checksum){
        this.checksum = new Checksum(checksum);
        return this;
    };

    var withLength = function(length){
        this.lValue = new LValue(calculateLValue(length));
        return this;
    };

    var withQuartiles = function(quartiles){
        var fromQValues = function(QLo, QHi){
            var calculateValue = function(QLo, QHi){
                return (((0 & 0xF0) | (QLo & 0x0F)) & 0x0F) | ((QHi & 0x0F) << 4);
            };

            return new Q(calculateValue(QLo, QHi));
        };
        
        this.q = new fromQValues(quartiles.getQ1Ratio(), quartiles.getQ2Ratio());
        
        return this;
    };

    var withBody = function(bodyData){
        this.body = new Body(bodyData);
        return this;
    };

    var build = function(){
        return new Digest(this.checksum, this.lValue, this.q, this.body);
    };

    var calculateLValue = function(length) {
        if(length <= Ranges.LOW) {
            return Math.floor(Math.log(length) / LOG_1_5) % MOD_VALUE;
        } 

        if(length <= Ranges.MID) {
            return Math.floor(Math.log(length) / LOG_1_3 - 8.72777) % MOD_VALUE;
        } 
            
        return Math.floor(Math.log(length) / LOG_1_1 - 62.5472) % MOD_VALUE;
    };

    return {
        withChecksum : withChecksum,
        withLength : withLength,
        withQuartiles : withQuartiles,
        withBody : withBody,
        build: build
    };
};

module.exports = DigestBuilder;
},{"../digests/body":9,"../digests/checksum":11,"../digests/digest":14,"../digests/lvalue":15,"../digests/q":17}],3:[function(require,module,exports){
var CalculatePearsonHash = (function() {

    var PERMUTATION_TABLE = [
        1, 87, 49, 12, 176, 178, 102, 166, 121, 193, 6, 84, 249, 230, 44, 163,
        14, 197, 213, 181, 161, 85, 218, 80, 64, 239, 24, 226, 236, 142, 38, 200,
        110, 177, 104, 103, 141, 253, 255, 50, 77, 101, 81, 18, 45, 96, 31, 222,
        25, 107, 190, 70, 86, 237, 240, 34, 72, 242, 20, 214, 244, 227, 149, 235,
        97, 234, 57, 22, 60, 250, 82, 175, 208, 5, 127, 199, 111, 62, 135, 248,
        174, 169, 211, 58, 66, 154, 106, 195, 245, 171, 17, 187, 182, 179, 0, 243,
        132, 56, 148, 75, 128, 133, 158, 100, 130, 126, 91, 13, 153, 246, 216, 219,
        119, 68, 223, 78, 83, 88, 201, 99, 122, 11, 92, 32, 136, 114, 52, 10,
        138, 30, 48, 183, 156, 35, 61, 26, 143, 74, 251, 94, 129, 162, 63, 152,
        170, 7, 115, 167, 241, 206, 3, 150, 55, 59, 151, 220, 90, 53, 23, 131,
        125, 173, 15, 238, 79, 95, 89, 16, 105, 137, 225, 224, 217, 160, 37, 123,
        118, 73, 2, 157, 46, 116, 9, 145, 134, 228, 207, 212, 202, 215, 69, 229,
        27, 188, 67, 124, 168, 252, 42, 4, 29, 108, 21, 247, 19, 205, 39, 203,
        233, 40, 186, 147, 198, 192, 155, 33, 164, 191, 98, 204, 165, 180, 117, 76,
        140, 36, 210, 172, 41, 54, 159, 8, 185, 232, 113, 196, 231, 47, 146, 120,
        51, 65, 28, 144, 254, 221, 93, 189, 194, 139, 112, 43, 71, 109, 184, 209
    ];

    var compute = function(data){
        var h = 0;

        data.forEach(function(i){
            h = PERMUTATION_TABLE[h ^ i];
        });

        return h;
    };

    return compute;
})();

module.exports = CalculatePearsonHash;
},{}],4:[function(require,module,exports){
var DigestBuilder = require('./digest-builder');

var ProcessedBuckets = function (checksum, bucketArray, processedDataLength, quartiles){
    
    var MINIMUM_HASH_INPUT_LENGTH = 512;
    var CODE_SIZE = 32;

    var isPositiveBucket = function(index){
        return bucketArray[index] > 0;
    };

    var hasMinimumNonZeroBuckets = function(){
        var nonzero = 0;

        for(var i=0; i < (CODE_SIZE*4); i++) {
            if (isPositiveBucket(i)) {
              nonzero++;
            }
        }

        return nonzero > (CODE_SIZE * 2);
    };

    var hasMinimumAmountOfDataProcessed = function(){
        return processedDataLength >= MINIMUM_HASH_INPUT_LENGTH;
    };

    var calculateBody = function(){
        var body = new Array(CODE_SIZE);
                
        for (var i = 0; i < CODE_SIZE; i++) {
            var h = 0;
            
            for (var j = 0; j < 4; j++) {
                var k1 = bucketArray[4 * i + j];
                
                if (quartiles.getThird() < k1) {
                    h += 3 << (j * 2);
                } else if (quartiles.getSecond() < k1) {
                    h += 2 << (j * 2);
                } else if (quartiles.getFirst() < k1) {
                    h += 1 << (j * 2);
                }
            }
            
            body[i] = h;
        }
        
        return body;
    };

    this.isProcessedDataTooSimple = function(){
        return !hasMinimumAmountOfDataProcessed() || !hasMinimumNonZeroBuckets();
    };

    this.buildDigest = function(){
        return new DigestBuilder()
                    .withChecksum(checksum)
                    .withLength(processedDataLength)
                    .withQuartiles(quartiles)
                    .withBody(calculateBody())
                    .build();
    };
};

module.exports = ProcessedBuckets;
},{"./digest-builder":2}],5:[function(require,module,exports){
var Quartiles = function (data){
    if(data.length < ARRAY_SAMPLE_SIZE) throw new Error();

    var ARRAY_SAMPLE_SIZE = 128;
    
    var Q_RATIO_MODULE = 16;

    var sampleArray = data.slice(0, ARRAY_SAMPLE_SIZE).sort(function(a, b) {
        return (a - b);
    });

    this.getQ1Ratio = function() {
        return Math.floor(this.getFirst() * 100 / this.getThird()) % Q_RATIO_MODULE;
    };

    this.getQ2Ratio = function() {
        return Math.floor(this.getSecond() * 100 / this.getThird()) % Q_RATIO_MODULE;
    };

    this.getFirst = function(){
        return sampleArray[ARRAY_SAMPLE_SIZE / 4 - 1];
    };

    this.getSecond = function(){
        return sampleArray[ARRAY_SAMPLE_SIZE / 2 - 1];
    };

    this.getThird = function() {
        return sampleArray[ARRAY_SAMPLE_SIZE - (ARRAY_SAMPLE_SIZE / 4) - 1];
    };
};

module.exports = Quartiles;
},{}],6:[function(require,module,exports){
var Triplet = require('./triplet');

var SlideWindow = function (){

    var SLIDING_WINDOW_SIZE = 5;

    var CHECKSUM_LENGTH = 1;

    var storage = new Array(SLIDING_WINDOW_SIZE);

    var counter = 0;

    var getValue = function(index){
        return storage[index];
    };

    var getHash = function(c1, c2, c3, salt){
        return new Triplet(c1, c2, c3, salt).getHash();
    };

    var isComplete = function(){
        return counter >= SLIDING_WINDOW_SIZE;
    };

    this.put = function(value){
        storage[this.getPivot()] = value & 0xff;
        counter++;
    };

    this.getPivot = function(){
        return counter % SLIDING_WINDOW_SIZE;
    };

    this.getTripletHashes = function(fromStartWindow){
        if(!isComplete()) return [];

        var startWindow = fromStartWindow;
        var j2 = (startWindow + 1) % SLIDING_WINDOW_SIZE;
        var j3 = (startWindow + 2) % SLIDING_WINDOW_SIZE;
        var j4 = (startWindow + 3) % SLIDING_WINDOW_SIZE;
        var endWindow = (startWindow + 4) % SLIDING_WINDOW_SIZE;

        return [
            getHash(storage[startWindow], storage[endWindow], storage[j4], 2),
            getHash(storage[startWindow], storage[endWindow], storage[j3], 3),
            getHash(storage[startWindow], storage[j4], storage[j3], 5),
            getHash(storage[startWindow], storage[j4], storage[j2], 7),
            getHash(storage[startWindow], storage[endWindow], storage[j2], 11),
            getHash(storage[startWindow], storage[j3], storage[j2], 13)
        ];
    };

    this.getChecksum = function(fromStartWindow, lastChecksum){
        if(!isComplete()) return null;
        
        var endWindow = (fromStartWindow + 4) % SLIDING_WINDOW_SIZE;
        
        var checksum = new Array(CHECKSUM_LENGTH);
        
        for (var i = 0; i < CHECKSUM_LENGTH; i++) {         
            var c1 = getValue(fromStartWindow);         
            var c2 = getValue(endWindow);           
            var c3 = 0;         
            var salt = 0;
            
            if(lastChecksum){
                c3 = lastChecksum[i];
            }
            
            if (i !== 0) {
                salt = checksum[i - 1];
            }
            
            checksum[i] = getHash(c1, c2, c3, salt);
        }
        
        return checksum;
    };
};

module.exports = SlideWindow;
},{"./triplet":7}],7:[function(require,module,exports){
var calculatePearsonHash = require('./pearson-hash');

var Triplet = function (c1, c2, c3, salt){
	this.c1 = c1;
	this.c2 = c2;
	this.c3 = c3;
	this.salt = salt;
};

Triplet.prototype.getHash = function(){
	return calculatePearsonHash([this.salt, this.c1, this.c2, this.c3]);
};

module.exports = Triplet;
},{"./pearson-hash":3}],8:[function(require,module,exports){
var CalculateBitPairsMappedValue = (function(){
    
    var BIT_PAIRS_DIFF_TABLE_SIZE = 256;

    var BIT_PAIRS_DIFF_TABLE = generateDefaultBitPairsTable();

    function generateDefaultBitPairsTable() {
        var result = new Array(BIT_PAIRS_DIFF_TABLE_SIZE);

        for (var i = 0; i < result.length; i++) {
            result[i] = new Array(BIT_PAIRS_DIFF_TABLE_SIZE);   
        }

        for (i = 0; i < BIT_PAIRS_DIFF_TABLE_SIZE; i++) {
            for (var j = 0; j < BIT_PAIRS_DIFF_TABLE_SIZE; j++) {
                var x = i;
                var y = j;
                var diff = 0;

                for (var z = 0; z < 4; z++) {
                    var d = Math.abs(x % 4 - y % 4);
                    
                    if(d == 3){
                        diff += d * 2;
                    } else {
                        diff += d;
                    }

                    if (z < 3) {
                        x = Math.floor(x / 4);
                        y = Math.floor(y / 4);
                    }
                }

                result[i][j] = diff;
            }
        } 

        return result;
    }    

    var getValue = function(row, column){
        return BIT_PAIRS_DIFF_TABLE[row][column];
    };

    return getValue;
})();

module.exports = CalculateBitPairsMappedValue;
},{}],9:[function(require,module,exports){
var calculateBitPairsMappedValue = require('./bit-pairs-table');

var Body = function (value){
    var hDistance = function(other){
        var diff = 0;

        for (var i = 0; i < value.length; i++) {
            diff += calculateBitPairsMappedValue(value[i], other.getValue(i));
        }
        
        return diff;
    };

    this.calculateDifference = function(other) {
        return hDistance(other);
    };

    this.getValue = function(index){
        return value[index];
    };
};

module.exports = Body;

},{"./bit-pairs-table":8}],10:[function(require,module,exports){
module.exports = function (data) {
    var result = ((data & 0xF0) >> 4) & 0x0F;
    result |= ((data & 0x0F) << 4) & 0xF0;

    return result;
};
},{}],11:[function(require,module,exports){
var Checksum = function (checksumData){

    var areEquals = function (anArray, otherArray) {
        var i = anArray.length;
        
        if (i != otherArray.length) return false;
       
        while (i--) {
            if (anArray[i] !== otherArray[i]) return false;
        }

        return true;
    };

    this.calculateDifference = function(other) {
        if (!areEquals(checksumData, other.getValue())) return 1;
        return 0;
    };

    this.getValue = function(){
        return checksumData;
    };
};

module.exports = Checksum;

},{}],12:[function(require,module,exports){
var Body = require('./body');
var Checksum = require('./checksum');
var Digest = require('./digest');
var LValue = require('./lvalue');
var Q = require('./q');

var swap = require('./byte-swapper');

var DigestHashBuilder = function() {
    
    var CODE_SIZE = 32;

    var checksum;

    var lValue;

    var q;

    var body;

    var withHash = function(hash){
        var digestData = fromHex(hash);
        var i = 0;

        withChecksumData(digestData[i++]);
        withLValueData(digestData[i++]);
        withQData(digestData[i++]);
        withBodyData(getBodyData(digestData, i));

        return this;
    };

    var build = function() {
        return new Digest(checksum, lValue, q, body);
    };

    var fromHex = function(str){
        var result = new Array(str.length / 2);

        for (var i = 0; i < str.length; i += 2) {
            result[i / 2] = parseInt(str.substring(i, i + 2), 16);
        }

        return result;
    };

    var withChecksumData = function(data){
        checksum = new Checksum([swap(data)]);
    };

    var withLValueData = function(data){
        lValue = new LValue([swap(data)]);
    };

    var withQData = function(data){
        q = new Q([swap(data)]);
    };

    var withBodyData = function(data){
        var bodyData = new Array(data.length);
        
        for(var j = 0; j < data.length; j++) {
            bodyData[j] = (data[data.length - 1 - j]);
        }
        
        body = new Body(bodyData);
    };

    var getBodyData = function(data, from){
        return data.slice(from, data.length);
    };

    return {
        withHash: withHash,
        build: build
    };
};

module.exports = DigestHashBuilder;
},{"./body":9,"./byte-swapper":10,"./checksum":11,"./digest":14,"./lvalue":15,"./q":17}],13:[function(require,module,exports){
var swap = require('./byte-swapper');

var ComposeString = (function() {

    return function(digest){

        var TLSH_CHECKSUM_LEN = 1;

        var CODE_SIZE = 32;

        var toHex = function(data){
            var result = "";

            for (var i=0; i < data.length; i++) {
                if (data[i] < 16) {
                    result += '0';
                }

                result += data[i].toString(16).toUpperCase();
            }   

            return result;
        };

        var swapChecksum = function(checksum){
            var swappedChecksum = new Array(TLSH_CHECKSUM_LEN);

            for (k = 0; k < TLSH_CHECKSUM_LEN; k++) {    
                swappedChecksum[k] = swap(checksum.getValue()[k]);
            }

            return toHex(swappedChecksum);
        };

        var swapLValue = function(lValue){
            return toHex([swap(lValue.getValue())]);
        };

        var swapQ = function(q){
            return toHex([swap(q.getValue())]);
        };

        var swapBody = function(body){
            var swappedBody = new Array(CODE_SIZE);
            
            for(i=0; i < CODE_SIZE; i++ ){
                swappedBody[i] = body.getValue(CODE_SIZE - 1 - i);
            }

            return toHex(swappedBody);
        };

        var string = "";

        string += swapChecksum(digest.getChecksum());
        string += swapLValue(digest.getLValue());
        string += swapQ(digest.getQ());
        string += swapBody(digest.getBody());

        return string;
    };

})();

module.exports = ComposeString;
},{"./byte-swapper":10}],14:[function(require,module,exports){
var composeString = require('./digest-string-composer');

var Digest = function (checksum, lValue, q, body){

    this.getLValue = function(){
        return lValue;
    };

    this.getQ = function(){
        return q;
    };

    this.getChecksum = function(){
        return checksum;
    };

    this.getBody = function(){
        return body;
    };

    this.calculateDifference = function(other, lengthDiff){
        var difference = 0;

        if(lengthDiff){
            difference += lValue.calculateDifference(other.getLValue());
        }

        difference += q.calculateDifference(other.getQ());
        difference += checksum.calculateDifference(other.getChecksum());
        difference += body.calculateDifference(other.getBody());

        return difference;
    };

    this.toString = function(){
        return composeString(this);
    };
};

module.exports = Digest;
},{"./digest-string-composer":13}],15:[function(require,module,exports){
var calculateModularDifference = require('./modular-difference-calculator');

var LValue = function (value){

    var RANGE_LVALUE = 256;

    this.calculateDifference = function(other){
        var ldiff = calculateModularDifference(value, other.getValue(), RANGE_LVALUE);

        if(ldiff === 0){
            return 0;
        }

        if(ldiff === 1){
            return 1;
        }

        return ldiff * 12;
    };

    this.getValue = function(){
        return value;
    };
};

module.exports = LValue;
},{"./modular-difference-calculator":16}],16:[function(require,module,exports){
module.exports = function (initialPosition, finalPosition, circularQueueSize) {
    var internalDistance = Math.abs(finalPosition - initialPosition);
    var externalDistance = circularQueueSize - internalDistance;

    return Math.min(internalDistance, externalDistance);
};
},{}],17:[function(require,module,exports){
var calculateModularDifference = require('./modular-difference-calculator');

var Q = function (value){
    
    this.getQLo = function(){
        return value & 0x0F;
    };

    this.getQHi = function(){
        return (value & 0xF0) >> 4; 
    };

    this.calculateDifference = function(other){
        var RANGE_QRATIO = 16;
        
        var diff = 0;

        var q1diff = calculateModularDifference(this.getQLo(), other.getQLo(), RANGE_QRATIO);

        if(q1diff <= 1){
            diff += q1diff;
        }  else {
            diff += (q1diff - 1) * 12;
        }

        var q2diff = calculateModularDifference(this.getQHi(), other.getQHi(), RANGE_QRATIO);

        if (q2diff <= 1) {
            diff += q2diff;
        } else {
            diff += (q2diff - 1) * 12;
        }
        
        return diff;
    };

    this.getValue = function(){
        return value;
    };
};

module.exports = Q;
},{"./modular-difference-calculator":16}],18:[function(require,module,exports){
var InsufficientComplexityError = function(message) {
  this.name = 'InsufficientComplexityError';
  this.message = message;
  this.stack = (new Error()).stack;
};

InsufficientComplexityError.prototype = Object.create(Error.prototype);
InsufficientComplexityError.prototype.constructor = InsufficientComplexityError;

module.exports = InsufficientComplexityError;
},{}],19:[function(require,module,exports){
var processBuckets = require('./buckets/bucket-processor');
var InsufficientComplexityError = require('./errors/insufficient-complexity-error');

module.exports.hash = function(data){
      var processedBuckets = processBuckets(data);

      if (processedBuckets.isProcessedDataTooSimple()) {
          throw new InsufficientComplexityError("Input data hasn't enough complexity");
      }

      return processedBuckets.buildDigest().toString();
  };

module.exports.DigestHashBuilder = require('./digests/digest-hash-builder');

},{"./buckets/bucket-processor":1,"./digests/digest-hash-builder":12,"./errors/insufficient-complexity-error":18}]},{},[19])(19)
});